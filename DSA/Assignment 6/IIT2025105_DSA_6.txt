Q1


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX 100
#define MAX_LEN 1000

char undoStack[MAX][MAX_LEN];
char redoStack[MAX][MAX_LEN];
int undoTop = -1, redoTop = -1;

char doc[MAX_LEN] = "";

void pushUndo() {
    undoTop++;
    strcpy(undoStack[undoTop], doc);
}

void pushRedo() {
    redoTop++;
    strcpy(redoStack[redoTop], doc);
}

void clearRedo() {
    redoTop = -1;
}

void typeText(char *text) {
    pushUndo();
    strcat(doc, text);
    clearRedo();
}

void deleteText(int k) {
    pushUndo();
    int len = strlen(doc);
    if (k > len) k = len;
    doc[len - k] = '\0';
    clearRedo();
}

void undo() {
    if (undoTop == -1) {
        printf("Nothing to undo\n");
        return;
    }
    pushRedo();
    strcpy(doc, undoStack[undoTop]);
    undoTop--;
}

void redo() {
    if (redoTop == -1) {
        printf("Nothing to redo\n");
        return;
    }
    pushUndo();
    strcpy(doc, redoStack[redoTop]);
    redoTop--;
}

int main() {
    int N;
    scanf("%d", &N);

    for (int i = 0; i < N; i++) {
        char cmd[20];
        scanf("%s", cmd);

        if (strcmp(cmd, "TYPE") == 0) {
            char text[100];
            scanf("%s", text);
            typeText(text);
        }
        else if (strcmp(cmd, "DELETE") == 0) {
            int k;
            scanf("%d", &k);
            deleteText(k);
        }
        else if (strcmp(cmd, "UNDO") == 0) {
            undo();
        }
        else if (strcmp(cmd, "REDO") == 0) {
            redo();
        }
        else if (strcmp(cmd, "PRINT") == 0) {
            printf("%s\n", doc);
        }
    }

    return 0;
}


Q2

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX 1000

int history[MAX];
int top = -1;

void pushHistory(int x) {
    history[++top] = x;
}

void popHistory() {
    if (top >= 0) top--;
}

int peekHistory() {
    if (top >= 0) return history[top];
    return -1;
}

void clearHistory() {
    top = -1;
}

int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

int applyOp(int a, int b, char op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;  
    }
    return 0;
}

int evaluate(char *exp) {
    int values[MAX], vtop = -1;
    char ops[MAX];
    int otop = -1;

    for (int i = 0; exp[i]; i++) {

        if (isspace(exp[i]))
            continue;

        if (isdigit(exp[i])) {
            int val = 0;
            while (i < strlen(exp) && isdigit(exp[i])) {
                val = val * 10 + (exp[i] - '0');
                i++;
            }
            values[++vtop] = val;
            i--;
        }

        else if (exp[i] == '(') {
            ops[++otop] = exp[i];
        }

        else if (exp[i] == ')') {
            while (otop >= 0 && ops[otop] != '(') {
                int b = values[vtop--];
                int a = values[vtop--];
                char op = ops[otop--];
                values[++vtop] = applyOp(a, b, op);
            }
            otop--; 
        }

        else {
            while (otop >= 0 && precedence(ops[otop]) >= precedence(exp[i])) {
                int b = values[vtop--];
                int a = values[vtop--];
                char op = ops[otop--];
                values[++vtop] = applyOp(a, b, op);
            }
            ops[++otop] = exp[i];
        }
    }

    while (otop >= 0) {
        int b = values[vtop--];
        int a = values[vtop--];
        char op = ops[otop--];
        values[++vtop] = applyOp(a, b, op);
    }

    return values[vtop];
}

int main() {
    int N;
    scanf("%d", &N);
    getchar();  

    while (N--) {
        char cmd[10];
        char expr[100];

        scanf("%s", cmd);

        if (strcmp(cmd, "EVAL") == 0) {
            getchar(); 
            fgets(expr, sizeof(expr), stdin);
            expr[strcspn(expr, "\n")] = 0;

            int result = evaluate(expr);
            pushHistory(result);
        }
        else if (strcmp(cmd, "LAST") == 0) {
            printf("%d\n", peekHistory());
        }
        else if (strcmp(cmd, "UNDO") == 0) {
            popHistory();
        }
        else if (strcmp(cmd, "CLEAR") == 0) {
            clearHistory();
        }
    }

    return 0;
}


Q3

#include <stdio.h>
#include <string.h>

#define MAX 1000

char stack[MAX];
int top = -1;

void push(char c) {
    stack[++top] = c;
}

char pop() {
    return stack[top--];
}

int isMatching(char open, char close) {
    if (open == '(' && close == ')') return 1;
    if (open == '{' && close == '}') return 1;
    if (open == '[' && close == ']') return 1;
    return 0;
}

int main() {
    char expr[MAX];
    scanf("%s", expr);

    for (int i = 0; expr[i] != '\0'; i++) {
        char ch = expr[i];

        if (ch == '(' || ch == '{' || ch == '[') {
            push(ch);
        }
        else if (ch == ')' || ch == '}' || ch == ']') {
            if (top == -1) {
                printf("NOT BALANCED\n");
                return 0;
            }
            char open = pop();
            if (!isMatching(open, ch)) {
                printf("NOT BALANCED\n");
                return 0;
            }
        }
    }

    if (top == -1)
        printf("BALANCED\n");
    else
        printf("NOT BALANCED\n");

    return 0;
}

Q4
#include <stdio.h>

#define MAX 1000

int stack[MAX];
int top = -1;

void push(int x) {
    stack[++top] = x;
}

int pop() {
    return stack[top--];
}

int peek() {
    if (top == -1) return -1;
    return stack[top];
}

int main() {
    int N;
    scanf("%d", &N);

    int order[MAX];
    for (int i = 0; i < N; i++) {
        scanf("%d", &order[i]);
    }

    int nextArrival = 1;

    for (int i = 0; i < N; i++) {
        int need = order[i];
 
        
        while (nextArrival <= N && (top == -1 || peek() != need)) {
            push(nextArrival);
            nextArrival++;
        }

        if (peek() == need) {
            pop();
        } else {
            printf("IMPOSSIBLE\n");
            return 0;
        }
    }

    printf("POSSIBLE\n");
    return 0;
}


